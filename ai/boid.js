// Generated by CoffeeScript 1.7.1
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(['inject'], function(inject) {
    var Boid;
    return Boid = (function() {
      function Boid(options) {
        this.cohere = __bind(this.cohere, this);
        this.align = __bind(this.align, this);
        this.separate = __bind(this.separate, this);
        this.step = __bind(this.step, this);
        inject.one('register coordinates')(this, options.position);
        inject.one('register physics')(this, options.velocity);
        inject.one('register display')(this, options.name);
      }

      Boid.prototype.step = function() {
        this.separate();
        this.align();
        return this.cohere();
      };

      Boid.prototype.separate = function() {
        var averagerepulsion, force;
        averagerepulsion = createVector(0, 0);
        inject.one('each by distance')(this.c.p, 25, (function(_this) {
          return function(d, boid) {
            var diff;
            if (boid === _this) {
              return;
            }
            diff = p5.Vector.sub(_this.c.p, boid.c.p);
            diff.div(diff.mag() * 2);
            return averagerepulsion.add(diff);
          };
        })(this));
        if (averagerepulsion.mag() === 0) {
          return;
        }
        force = inject.one('calculate steering')(this, averagerepulsion);
        force.mult(4.5);
        return inject.one('apply force')(this, force);
      };

      Boid.prototype.align = function() {
        var averagedirection, forece;
        averagedirection = createVector(0, 0);
        inject.one('each by distance')(this.c.p, 50, (function(_this) {
          return function(d, boid) {
            if (boid === _this) {
              return;
            }
            return averagedirection.add(boid.p.v);
          };
        })(this));
        if (averagedirection.mag() === 0) {
          return;
        }
        forece = inject.one('calculate steering')(this, averagedirection);
        forece.mult(1.0);
        return inject.one('apply force')(this, forece);
      };

      Boid.prototype.cohere = function() {
        var averageposition, count, direction, force;
        averageposition = createVector(0, 0);
        count = 0;
        inject.one('each by distance')(this.c.p, 100, (function(_this) {
          return function(d, boid) {
            if (boid === _this) {
              return;
            }
            averageposition.add(boid.c.p);
            return count++;
          };
        })(this));
        if (averageposition.mag() === 0) {
          return;
        }
        averageposition.div(count);
        direction = p5.Vector.sub(averageposition, this.c.p);
        force = inject.one('calculate steering')(this, direction);
        force.mult(1.0);
        return inject.one('apply force')(this, force);
      };

      return Boid;

    })();
  });

}).call(this);
