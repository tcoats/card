// Generated by CoffeeScript 1.7.1
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(['inject', 'p2'], function(inject, p2) {
    var Boid;
    return Boid = (function() {
      function Boid(entity, n) {
        this.cohere = __bind(this.cohere, this);
        this.align = __bind(this.align, this);
        this.separate = __bind(this.separate, this);
        this.step = __bind(this.step, this);
        this.e = entity;
        this.n = n;
      }

      Boid.prototype.step = function() {
        this.separate();
        this.align();
        return this.cohere();
      };

      Boid.prototype.separate = function() {
        var averagerepulsion, force, istouched;
        averagerepulsion = [0, 0];
        inject.one('each by distance')(this.e.phys.b.position, 25, (function(_this) {
          return function(d, e) {
            var diff;
            if (e === _this.e || (e.ai == null)) {
              return;
            }
            diff = [0, 0];
            p2.vec2.sub(diff, _this.e.phys.b.position, e.phys.b.position);
            p2.vec2.normalize(diff, diff);
            return p2.vec2.add(averagerepulsion, averagerepulsion, diff);
          };
        })(this));
        istouched = p2.vec2.len(averagerepulsion) !== 0;
        inject.one('abs stat')(this.e, {
          istouched: istouched
        });
        if (!istouched) {
          return;
        }
        inject.one('scale to max velocity')(averagerepulsion);
        force = inject.one('calculate steering')(this.e.phys.b.velocity, averagerepulsion);
        p2.vec2.scale(force, force, 2);
        return inject.one('apply force')(this.e, force);
      };

      Boid.prototype.align = function() {
        var averagedirection, count, force;
        averagedirection = [0, 0];
        count = 0;
        inject.one('each by distance')(this.e.phys.b.position, 50, (function(_this) {
          return function(d, e) {
            if (e === _this.e || (e.ai == null)) {
              return;
            }
            p2.vec2.add(averagedirection, averagedirection, e.phys.b.velocity);
            return count++;
          };
        })(this));
        if (p2.vec2.len(averagedirection) === 0) {
          return;
        }
        inject.one('scale to max velocity')(averagedirection);
        force = inject.one('calculate steering')(this.e.phys.b.velocity, averagedirection);
        p2.vec2.scale(force, force, 0.5);
        return inject.one('apply force')(this.e, force);
      };

      Boid.prototype.cohere = function() {
        var averageposition, count, force, iscommunity, targetvelocity;
        averageposition = [0, 0];
        count = 0;
        inject.one('each by distance')(this.e.phys.b.position, 100, (function(_this) {
          return function(d, e) {
            if (e === _this.e || (e.ai == null)) {
              return;
            }
            p2.vec2.add(averageposition, averageposition, e.phys.b.position);
            return count++;
          };
        })(this));
        inject.one('abs stat')(this.e, {
          iscommunity: count > 0
        });
        iscommunity = count > 0;
        if (p2.vec2.len(averageposition) === 0) {
          return;
        }
        p2.vec2.scale(averageposition, averageposition, 1 / count);
        targetvelocity = inject.one('calculate seeking')(this.e.phys.b.position, averageposition);
        force = inject.one('calculate steering')(this.e.phys.b.velocity, targetvelocity);
        p2.vec2.scale(force, force, 1);
        return inject.one('apply force')(this.e, force);
      };

      return Boid;

    })();
  });

}).call(this);
