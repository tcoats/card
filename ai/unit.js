// Generated by CoffeeScript 1.7.1
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(['inject', 'p2'], function(inject, p2) {
    var Unit;
    return Unit = (function() {
      function Unit(entity, n) {
        this.align = __bind(this.align, this);
        this.separate = __bind(this.separate, this);
        this.step = __bind(this.step, this);
        this.e = entity;
        this.n = n;
      }

      Unit.prototype.step = function() {
        this.separate();
        return this.align();
      };

      Unit.prototype.separate = function() {
        var averagerepulsion, force, istouched;
        averagerepulsion = [0, 0];
        inject.one('each by distance')(this.e.phys.b.position, 25, (function(_this) {
          return function(d, e) {
            var diff;
            if (e === _this.e || (e.ai == null)) {
              return;
            }
            diff = [0, 0];
            p2.vec2.sub(diff, _this.e.phys.b.position, e.phys.b.position);
            p2.vec2.normalize(diff, diff);
            return p2.vec2.add(averagerepulsion, averagerepulsion, diff);
          };
        })(this));
        istouched = p2.vec2.len(averagerepulsion) !== 0;
        inject.one('abs stat')(this.e, {
          istouched: istouched
        });
        if (!istouched) {
          return;
        }
        inject.one('scale to max velocity')(averagerepulsion);
        force = inject.one('calculate steering')(this.e.phys.b.velocity, averagerepulsion);
        p2.vec2.scale(force, force, 1);
        return inject.one('apply force')(this.e, force);
      };

      Unit.prototype.align = function() {
        var alignpos, anticlockwise, closestdistance, closestunit, force, len1, len2, len3, nextclosestunit, normal, point1, point2, point3, position, target;
        this.e.target = null;
        closestunit = null;
        closestdistance = 200;
        inject.one('each by distance')(this.e.phys.b.position, 200, (function(_this) {
          return function(d, e) {
            if (e === _this.e || (e.ai == null)) {
              return;
            }
            if (d < closestdistance) {
              closestunit = e;
              return closestdistance = d;
            }
          };
        })(this));
        if (closestunit == null) {
          return;
        }
        position = p2.vec2.clone(closestunit.phys.b.position);
        p2.vec2.sub(position, position, this.e.phys.b.position);
        normal = [0, 0];
        p2.vec2.normalize(normal, position);
        p2.vec2.scale(normal, normal, 30);
        p2.vec2.sub(position, position, normal);
        this.e.target = p2.vec2.clone(position);
        p2.vec2.add(this.e.target, this.e.target, this.e.phys.b.position);
        nextclosestunit = null;
        closestdistance = 50;
        inject.one('each by distance')(closestunit.phys.b.position, 35, (function(_this) {
          return function(d, e) {
            if (e === _this.e || e === closestunit || (e.ai == null)) {
              return;
            }
            if (d < closestdistance) {
              nextclosestunit = e;
              return closestdistance = d;
            }
          };
        })(this));
        if (nextclosestunit != null) {
          alignpos = [0, 0];
          p2.vec2.sub(alignpos, closestunit.phys.b.position, nextclosestunit.phys.b.position);
          p2.vec2.normalize(alignpos, alignpos);
          p2.vec2.scale(alignpos, alignpos, 30);
          anticlockwise = function(vec) {
            var x, y;
            x = vec[0];
            y = vec[1];
            return [-y, x];
          };
          point1 = p2.vec2.clone(alignpos);
          point2 = [point1[1], -point1[0]];
          point3 = [-point1[1], point1[0]];
          p2.vec2.add(point1, closestunit.phys.b.position, point1);
          p2.vec2.add(point2, closestunit.phys.b.position, point2);
          p2.vec2.add(point3, closestunit.phys.b.position, point3);
          p2.vec2.sub(point1, point1, this.e.phys.b.position);
          p2.vec2.sub(point2, point2, this.e.phys.b.position);
          p2.vec2.sub(point3, point3, this.e.phys.b.position);
          len1 = p2.vec2.len(point1);
          len2 = p2.vec2.len(point2);
          len3 = p2.vec2.len(point3);
          target = null;
          if (len1 < len2) {
            target = point1;
          } else {
            target = point2;
          }
          this.e.target = p2.vec2.clone(target);
          p2.vec2.add(this.e.target, this.e.target, this.e.phys.b.position);
          inject.one('limit to max velocity')(target);
          force = [0, 0];
          p2.vec2.scale(force, target, 10);
          inject.one('apply force')(this.e, force);
          return;
        }
        force = [0, 0];
        inject.one('limit to max velocity')(position);
        p2.vec2.scale(force, position, 20);
        return inject.one('apply force')(this.e, force);
      };

      return Unit;

    })();
  });

}).call(this);
